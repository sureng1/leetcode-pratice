## 解题思路
* 面试应该没有那么多需要解题思路的，一般都是常见题吧
* 面试中应该解决的问题是紧张、催促自己快点做出来从而不能深入题目，最应该做的事情就是放松。
	* 放松才是提高思考效率的方法
	* 做的出来就是做的出来，做不出来就是做不出来
### 是在遇到新的题目了：

* 深入题目给出的性质，来构建方案：
	* 三数之和
* 【公式】双指针
	* 搜索时，一个增另外一个就会减少
	* 不能回溯
* 【公式】动态规划
* 【公式】DFS
* 【公式】二分、堆
	* 有序的序列
	* 可以加快搜索的节奏
	* 优先队列

## coding 常见的方法和错误
* 想出思路后，用多个能想到的case验证下，
* 写完后对照下是否按自己思路来的
* 写完后用case过一遍看有没有问题
* `改完`后一定也要看看是否符合思路，还有用case过一遍！！！经常出现改了出错，排查起来很困难也费时间！

* golang常见的coding问题：
	* 科学计数法: `a := 10e3 // 10000` `b := 1e3 // 1000`
	* 位操作: 
		```
		&   bitwise AND
		 |   bitwise OR
		 ^   bitwise XOR
		&^   AND NOT
		<<   left shift
		>>   right shift
		```
	* x的次方:
		```
		math.Pow(10, 2)
		```

## 排序
### 堆排序 23
每次还是老老实实看一遍，并实现一遍吧.
堆构建：自顶而下构建堆，把一个个节点顺序加入到堆的叶子节点上，加入后调整堆（如果叶子节点能提上去，那就提叶子节点），满足堆的性质。
Pop: 移除节点，从叶子节点（数组最后一个）提到堆顶，往下调整该节点，维护堆性质
Push: 节点加入到最后，然后往上提，直到父节点比该节点大，堆的性质不变。

* 选择最大节点的地方经常写错。
```
错误一 比较兄弟节点
  其实不需要比较兄弟节点，只需要找出最大的节点，然后交换，并调整被交换的节点，让它满足堆的性质即可。
```
* 另外不能用新切片来划分子堆，这样划分，后代关系就乱了，如 [0,1,2,3,4] 1的后代是 [3,4], 新切片中 [1,2,3,4], 1的后代就是 [2,3] 了，老实背一遍吧。
* 找父节点计算错了，应该是 (idx-1)/2 而不是  idx/2

### 快速排序 912
对于arr选择 arr[0] 作为基数，小于基数的放左边，大于基数的放右边。这种算法需要注意，选好基数后，从右边开始找比基数小的。

## 链表
### 记得清空尾指针，避免写后续代码漏清理
### 模块，创建链表
```
type TTNode struct {
	Val  int
	Next *TTNode
}

func getList(a []int) *TTNode {
	root := &TTNode{}
	var cur = root
	for _, ai := range a {
		cur.Next = &TTNode{Val: ai}
		cur = cur.Next
	}
	return root.Next
}
```
## 图
### 最短路径+以边建图 851
#### BFS 用golang实现的坑

```golang
// 正常情况下的视线
points := []int{}
for len(points) > 0 { // for i:=0;i<len(ppoints);i++
	// visited
	points = points[1:]
	// add points
	points = append(points, newP)
}
```

错误实现
```golang
for i, pi := range points { // 这是语法糖，等价于i:=0;i<len(points);i++ 执行到这里时，len(points) 就被固定了，导致新节点没有被遍历到。
	points = append(points, newP)
}
```

## BFS
### 隐式BFS 22
一般求满足条件的排列组合，都可以考虑能否通过BFS+剪枝

## 一些简单的数学知识
### 全排列
```
3 2 1 的全排列表示将 3 个数字 1、2、3 进行全排列。

步骤是:

首先固定1,后面2个数字有2种排列方法:2 3 和 3 2
然后固定2,后面2个数字有2种排列方法:1 3 和 3 1
最后固定3,后面2个数字有2种排列方法:1 2 和 2 1
所以总共有:2 + 2 + 2 = 6 种排列方法,它们是:

123
132
213
231
312
321
使用公式计算全排列数量的方法是:

设有n个不同元素,它们的全排列数量为:P(n)

那么公式为:P(n) = n * (n-1) * (n-2)...* 1
```

## 动态规划 32
### 什么时候可以使用动态规划
* 有明显的状态转移
* 结果会出现在状态中。





